Antes de hacer un commit debo especificar quien soy por 1ra vez. Para esto uso:
git config --global user.name "nombre de la persona"
git config --global user.email "un correo"
//--------------------------------------------------------

ls te indica un listado de los archivos de en donde estas en ese momento
GIT entiende mejor el texto plano que los archivos binarios como word y eso
cd ruta_que_quieres_ir es para cambiar el directorio e ir doned quieres ir cd / es el home
ls -a es que muestre los archivos pero no en lista
ls -al es que muestre todos los archivos incluso los ocultos y me los ponga en una lista
clear limpia la consola
cd .. te saca de la carpeta en la que te encuentras, un paso atras
mkdir nombre_carpeta es para crear carpetas. Debes fijarte donde estas parado para saber donde se va a crear
touch nombre_archivo.extension crea archivos vacios
. es la carpeta actual
.. es la carpeta anterior
cat nombre_archivo.extension muestra el contenido de un archivo
history muestra todos los comandos escritos
!numero_de_comando y te repite el comando que esta en esa linea que ha sido visto con el comando history
rm nombre_archivo.extension borra ese archivo(Cuidado con este, por que puede borrar el disco duro)
-Para crear un repo dbes decir donde esta la carpeta central de tus archivos y escribir git init. Es como decir donde esta el index.html de una app

-Cuando hago un git add lo guarda en memoria y para guardarlo de verdad uso git commit. EN caso de que le di git add a un archivo que no era, le puedo dar 
git rm cached nombre_archivo.extension y lo quita de memoria

-Un solo guion(-) indica que pasare una letra como argumento
-2 guiones (--) indica que pasare una palabra como argumento

-Para ver la diferecia de los cambios escribo
git diff copiar los numeros del commit presentados en el git log numeros de otro commit

-Si quieres unir el contenido de una rama con el contenido de otra rama se utiliza merge
Ejemplo: si tienes una rama con una cosa y otra rama con otra cosa el merge los une para tener una version final

-Conflicto es cuando un archivo rompe otro archivo cuando se hace un merge por ejemplo 


//------------------------------------------------------------------------
*Te posicionas sobre la carpeta que quieres que sea tu repo y le das git init, eso a traves de la consola de bash
-git init: empieza un repositorio en tu carpeta y es donde se van a guardar los cambios de tus archivos

-Pero tu carpeta debe saber que ese archivo existe entonces se utiliza:
git add nombre_de_archivo.extension

-Debes decirle que los cambios hechos en tus archivos estan listos. Entonces debes decir para que se guarden los ultimos cambios hechos, se utiliza:
git commit 

-Pero si quieres dejarle un mensaje para saber que cambiaste desde afuera puedes hacer:
git commit -m "Mensaje"

-Lo que hace es agregar todos los archivos que hayas cambiado en la carpeta donde estas
git add . 

-Despues de haber hecho git add . solo debes hacer otro commit para asegurar esos cambios

-Para saber el status de tu repositorio, puedes usar, con esto puedes saber si hay algun cambio que no hayas anadido y eso:
git status 

-Te va a mostrar todos los cambios historicos hechos, incluyendo las lineas de texto cambiadas y todo:
git show

-Para saber la historia entera de un archivo:
git log nombre_de_archivo.extension

-Te permite enviar hacia otro repositorio remoto, lo que estas haciendo:
git push 

-Para traer el archivo de otro repositorio:
git pull

--Para volver a una version anterior debemos utilizar 
git reset codigo_del_commit_que_quiero_ir visto con el git log

-Queremos que todo vuelva al estado anterior pero sin posibilidad de volver al futuro donde nos quedamos. Mejor usar git checkout, usamos:
git reset codigo_del_commit_que_quiero_ir --hard
git reset codigo_del_commit_que_quiero_ir --soft	//Lo que esta en cache o staging se queda en staging, sigue ahi pera el proximo commit

-Si quiero ver los cambios a nivel de bytes hago un
git log --stat
Si quiero salir del log solo debo darle a la letra Q

-Si queremos pasear por los cambios hechos anteriormente le damos 
git checkout codigo_del_commit_que_quiero_ir nombre_del_archivo.extension	//Con esto puedo ver esa version
get checkout master nombre_del_archivo.extension	//Con esto vuelvo a la version original donde estoy
//------------------------------------------------------------------------
//Historia hecha en el 1er curso

$ history
    1  ls
    2  cd
    3  pwd
    4  pwd
    5  git -version
    6  git version
    7  cd /c
    8  ls
    9  cd  users
   10  cd ..
   11  pwd
   12  cd Curso_Git
   13  cd
   14  ls
   15  ls -al
   16  cd Desktop
   17  cd Cursos
   18  cd Curso_Git
   19  git init
   20  code
   21  gi status
   22  git status
   23  git add historia.txt
   24  git status
   25  git commit -m "Este es el 1er commit de este archivo"
   26  git config
   27  git config --list
   28  git config --list --show -origin
   29  git config --global user.name "Luis Canot"
   30  git config --global user.email "luisr.sosa26@gmail.com"
   31  git commit -m "Este es el 1er commit de este archivo"
   32  code
   33  cat historia.txt
   34  code
   35  git status
   36  git commit -m "Cambios al archivo de historia para reflejar los cambios hechos"
   37  git add .
   38  git commit -m "Cambios al archivo de historia para reflejar los cambios hechos"
   39  history
   40  git log historia.txt
   41  history

//-------------------------------------------------------------------------------------------------------------------
Trabajar con un servidor remoto, es decir , cuando estamos en un equipo de trabajo y todos mandan info al servidor remoto para unificar tareas
-git clone url_del_servidor	//Crea una copia en tu directorio, tambien en el repositorio local y por ultimo en el repositorio remoto

--git push	//Cuando ya si quiero mandar el ultimo commit hecho al repositorio remoto
--git fetch	//Quiero traer una actualizacion del repositorio remoto por que alguien cambio algo
//git merge	//El git fetch lo trae al repo local pero no a mi directorio, entonces uso este git merge para que lo traiga al directorio tambien
--git pull	//Hace la funcion de git fetch y git merge. Trae los datos del repo remoto y los pone en mi directorio y en mi repo local
--git branch nombre_de_la_rama	//Crea una rama
--git checkout nombre_de_la_rama	//Te mueve a la rama que has creado, es decir , te mueve entre las ramas

-------------------------------------------------
Las ramas es la formas de hacer cambios sin afectar la rama principal que es master
El commit mas reciente es el que se llama HEAD
La rama se va a crear en el lugar en el que estoy
El git status te dice donde estas en la parte de "On branch master"
El git show puede mostrarte quien es el HEAD, en la parte HEAD <- master
Cuando haces muchos cambios en una rama es bueno hacerle un git commit -am "comentario" por si cambias de rama no se pierdan los cambios
Git branch escrito solo, te dice cuales y cuantas ramas han sido creadas
git merch nombre_rama_que_quier_que_venga	//Para salir del mensaje del merge, le doy End+Shift+Z+Z

El merge siempre va a ocurrir en la rama donde estoy, ojo ahi. Si estoy en cabecera y hago un merge, este se hara en cabecera, es decir, mando la info de master a cabecera. Entonces debo cambiarme a master en este caso para hacer el merge

'Puedo hacer git -am "Comentario"	/Esto hace add y commit a archivos que previamente les habia hecho git add sino no funcionara

//Nota:
Puedo crear una rama haciendo git branch, es decir, haces una copia exacta de la rama en la que estabas. Entonces puedo seguir modificando el archivo pero ya los cambios se refleajaran en la rama que he creado. Puedo moverme entre ramas con git checkout. Si hago un cambio en una rama, otras ramas no lo veran a menos que haga git merge.

//Manejo de conflictos al hacer un merge



